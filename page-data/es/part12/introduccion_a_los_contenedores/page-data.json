{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/introduccion_a_los_contenedores","result":{"data":{"markdownRemark":{"html":"<div class=\"tasks\">\n<p>Esta parte fue actualizada el 21 de Marzo de 2024: Create react app reemplazado con Vite en el frontend de todo.</p>\n<p>Si comenzaste esta parte antes de la actualización, puedes ver el viejo material <a href=\"https://github.com/fullstack-hy2020/fullstack-hy2020.github.io/tree/4015af9dddb61cb01f013456d8728e8f553be347/src/content/12\">aquí</a>. Hay algunos cambios en las configuraciones del frontend.</p>\n</div>\n<div class=\"content\">\n<p>El desarrollo de software incluye un amplio ciclo, desde imaginar el software hasta la programación y el lanzamiento al usuario final, e incluso su mantenimiento. Esta parte será una introducción a los contenedores, una herramienta moderna utilizada en las partes finales del ciclo de desarrollo de software.</p>\n<p>Los contenedores encapsulan tu aplicación en un solo paquete. Este paquete incluirá a la aplicación y a todas sus dependencias. Como resultado, cada contenedor puede correr aislado de otros contenedores.</p>\n<p>Los contenedores previenen que la aplicación pueda acceder a los archivos y recursos del dispositivo. Los desarrolladores pueden establecer permisos a las aplicaciones para que accedan a los archivos y también especificar recursos disponibles. Más precisamente, los contenedores son virtualizaciones a nivel de Sistema Operativo ( OS-level virtualization ). La comparación más cercana es con una máquina virtual (VM). VMs son utilizadas para ejecutar múltiples sistemas operativos en una misma máquina física. Ellas tienen que ejecutar todo el sistema operativo, mientras que los contenedores ejecutan el software utilizando el sistema operativo del host. La diferencia resultante entre las máquinas virtuales y los contenedores es que se consumen menos recursos cuando se ejecutan contenedores; solo necesitan ejecutar un solo proceso.</p>\n<p>Como los contenedores son relativamente ligeros, al menos comparados con las máquinas virtuales, estos pueden escalar rápidamente. Y como aíslan el software que ejecutan dentro, permiten que el software se ejecute de manera idéntica en cualquier ambiente. Por ello, son la opción preferida en cualquier entorno basado en la nube o aplicación con más de un puñado de usuarios.</p>\n<p>Servicios como AWS, Google Cloud y Microsoft Azure soportan contenedores en diferentes formas. Estos incluyen a AWS Fargate y Google Cloud Run, ambos permiten ejecutar los contenedores sin servidor (serverless) - donde el contenedor de la aplicación ni siquiera necesita estar ejecutándose si no es utilizado. También puedes instalar un entorno de ejecución de contenedores en la mayoría de los ordenadores y ejecutarlos tú mismo- incluyendo tu propia máquina.</p>\n<p>Por lo que los contenedores son utilizados en ambientes en la nube e incluso durante el desarrollo. Cuáles son los beneficios de utilizar contenedores? He aquí dos escenarios comunes:</p>\n<p><i>Escenario 1: Estás desarrollando una aplicación nueva que necesita ejecutarse en la misma máquina que una aplicación antigua (legacy). Ambas requieren instalar diferentes versiones de Node.</i></p>\n<p>Probablemente puedas utilizar nvm, máquinas virtuales o magia negra para lograr ejecutarlas al mismo tiempo. Sin embargo los contenedores son una excelente solución ya que puedes ejecutar ambas aplicaciones en sus respectivos contenedores. Ellas están aisladas una de otra y no interfieren.</p>\n<p><i>Escenario 2: Tu aplicación se ejecuta en tu ordenador. Necesitas mover la aplicación a un servidor</i></p>\n<p>No es poco común que la aplicación simplemente no se ejecute en el servidor a pesar de estar trabajando bien en tu ordenador. Esto puede ocurrir debido a algunas dependencias faltantes o otras diferencias en los entornos. Aquí los contenedores son una excelente solución ya que puedes ejecutar tu aplicación en el mismo ambiente tanto en tu ordenador como en el servidor. No es perfecto: las diferencias en el hardware pueden provocar incidentes, pero puedes limitar estas diferencias entre los ambientes.</p>\n<p>Alguna vez podrás escuchar sobre el problema <i>\"Works in my container\"</i> (Funciona en mi contenedor). La frase describe la situación en la que la aplicación funciona bien en un contenedor ejecutándose en tu ordenador pero se rompe cuando el contenedor es iniciado en el servidor. Esta frase es una variante del infame problema <i>\"Works on my machine\"</i> (Funciona en mi maquina), que con frecuencia los contenedores resuelven. La situación es también con mucha certeza, un error de uso.</p>\n<h3>Sobre esta parte</h3>\n<p>En esta parte, el foco de nuestra atención no estará en el código JavaScript. En cambio, nos interesa la configuración del entorno en el que se ejecuta el software. Como resultado, es posible que los ejercicios no contengan nada de código, las aplicaciones están disponibles a través de GitHub y sus tareas incluirán configurarlas. Los ejercicios deben enviarse a <i>un solo repositorio de GitHub</i> que incluirá todo el código fuente y las configuraciones que realizes durante esta parte.</p>\n<p>Necesitarás conocimientos básicos de Node, Express y React. Solo las partes principales, 1 a 5, deben ser completadas antes de esta parte.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.1</h3>\n<h3><i>Advertencia</i></h3>\n<p>Dado que estamos saliendo de nuestra zona de confort como desarrolladores de JavaScript, esta parte puede requerir que tomes un desvío para familiarizarte con shell / línea de comandos/ intérprete de comandos / terminal antes de comenzar.</p>\n<p>Si solo has utilizado una interfaz gráfica de usuario y nunca has tocado, por ejemplo, Linux o el terminal en Mac, o si te quedas atascado en los primeros ejercicios, te recomendamos hacer primero la Parte 1 de \"Herramientas informáticas para estudios de CS\": <a href=\"https://tkt-lapio.github.io/en/\">https://tkt-lapio.github.io/en/</a>. Omite la sección \"Conexión SSH\" y el Ejercicio 11. ¡Esto incluye todo lo que necesitaras para comenzar aquí!</p>\n<h4>Ejercicio 12.1: Usando una computadora (sin la interfaz gráfica de usuario)</h4>\n<p>Paso 1: Lee el texto debajo del titulo \"Advertencia\".</p>\n<p>Paso 2: Descarga este <a href=\"https://github.com/fullstack-hy2020/part12-containers-applications\">repositorio</a> y conviértelo en tu repositorio de envío para esta parte del curso.</p>\n<p>Paso 3: Ejecuta <i>curl <a href=\"http://helsinki.fi\">http://helsinki.fi</a></i> y guarda el resultado en un archivo. Guarda el archivo en tu repositorio con el nombre <i>script-answers/exercise12_1.txt</i>. El directorio <i>script-answers</i> ha sido creado en el paso anterior.</p>\n</div>\n<div class=\"content\">\n<h3>Enviar los ejercicios y recibir los créditos</h3>\n<p>Envía los ejercicios utilizando el <a href=\"https://studies.cs.helsinki.fi/stats/\">sistema de envío</a> igual que en las partes anteriores. Los ejercicios de esta parte son enviados <i>a su <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">propia instancia del curso</a></i>.</p>\n<p>Completar esta parte supondrá la obtención de 1 crédito. Ten en cuenta que debes realizar todos los ejercicios para obtener el crédito o el certificado.</p>\n<p>Cuando completes los ejercicios y desees obtener los créditos, déjanoslo saber a través del sistema de envío de ejercicios que has completado el curso:</p>\n<picture><img src=\"/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png\" alt=\"Enviando los ejercicios para obtener los créditos\" srcset=\"/static/ba7a651de70d2d2e13697df135255a90/772e8/23.png 200w,\n/static/ba7a651de70d2d2e13697df135255a90/e17e5/23.png 400w,\n/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png 800w,\n/static/ba7a651de70d2d2e13697df135255a90/c1b63/23.png 1200w,\n/static/ba7a651de70d2d2e13697df135255a90/29007/23.png 1600w,\n/static/ba7a651de70d2d2e13697df135255a90/50e7d/23.png 1738w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Puedes descargar el certificado de finalización de esta parte dando click en uno de los íconos de las banderas. Cada bandera corresponde con el idioma del certificado.</p>\n<h3>Herramientas del oficio</h3>\n<p>Las herramientas básicas que necesitaras varían de acuerdo a los sistemas operativos:</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">Terminal WSL 2</a> en Windows</li>\n<li>Terminal en Mac</li>\n<li>Command Line en Linux</li>\n</ul>\n<h3>Instalando todo lo necesario para esta parte</h3>\n<p>Comenzaremos instalando el software necesario. El paso de instalación será uno de los posibles obstáculos. Como estamos tratando con la virtualización a nivel del sistema operativo, las herramientas requerirán acceso de superusuario en el ordenador. Tendrán acceso al kernel de tu sistema operativo.</p>\n<p>Este material está basado en <a href=\"https://www.docker.com/\">Docker</a>, un conjunto de productos que utilizaremos para la contenedorización y la administración de los contenedores. Desafortunadamente si no puedes instalar Docker probablemente no podrás completar esta parte.</p>\n<p>Como las instrucciones de instalación dependen de tu sistema operativo, deberás encontrar las instrucciones de instalación correctas en el siguiente enlace. Ten en cuenta que pueden haber múltiples opciones diferentes para tu sistema operativo.</p>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\">Obtén Docker</a></li>\n</ul>\n<p>Ahora que esperamos que ese dolor de cabeza haya terminado, asegurémonos de que nuestras versiones coincidan. La tuya puede tener números un poco más altos que esta:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token parameter variable\">-v</span>\nDocker version <span class=\"token number\">25.0</span>.3, build 4debf41</code></pre></div>\n<h3>Contenedores e imágenes</h3>\n<p>Hay dos conceptos básicos en esta parte: <i>contenedores</i> e <i>imágenes</i>. Los cuales son fáciles de confundir entre sí:</p>\n<p>Un <i>contenedor</i> es una instancia en tiempo de ejecución de una <i>imagen</i>.</p>\n<p>Las dos afirmaciones siguientes son verdaderas:</p>\n<ul>\n<li>Las imágenes incluyen todo el código, dependencias e instrucciones sobre cómo ejecutar la aplicación</li>\n<li>Los contenedores empaquetan software en unidades estandarizadas</li>\n</ul>\n<p>No es de extrañar que se confundan fácilmente.</p>\n<p>Para ayudar con la confusión, casi todos usan la palabra contenedor para describir ambos. Pero en realidad nunca se puede construir un contenedor o descargar uno, ya que los contenedores solo existen durante el tiempo de ejecución. Las imágenes, por otro lado, son archivos <strong>inmutables</strong>. Como resultado de la inmutabilidad, no puedes editar una imagen después de haberla creado. Sin embargo, puedes usar imágenes existentes para crear <i>una nueva imagen</i> agregando nuevas capas encima de las existentes.</p>\n<p>Metáfora de la cocina:</p>\n<ul>\n<li>La imagen es un manjar pre-cocinado y congelado.</li>\n<li>El contenedor es el delicioso manjar.</li>\n</ul>\n<p><a href=\"https://www.docker.com/\">Docker</a> es la tecnología de contenedorización más popular y fue pionera en los estándares que la mayoría de las tecnologías de contenedorización utilizan en la actualidad. En la práctica, Docker es un conjunto de productos que nos ayudan a gestionar imágenes y contenedores. Este conjunto de productos nos permitirá aprovechar todos los beneficios de los contenedores. Por ejemplo, el motor de Docker se encargará de convertir los archivos inmutables llamados imágenes en contenedores.</p>\n<p>Para administrar los contenedores Docker, también existe una herramienta llamada <a href=\"https://docs.docker.com/compose/\">Docker Compose</a> que permite <strong>orquestar</strong> (controlar) varios contenedores al mismo tiempo. En esta parte, utilizaremos Docker Compose para configurar un entorno de desarrollo local complejo. En la versión final del entorno de desarrollo que configuraremos, incluso instalar Node en nuestra máquina ya no sera un requisito.</p>\n<p>Hay varios conceptos que necesitamos repasar. ¡Pero los omitiremos por ahora y aprenderemos sobre Docker primero!</p>\n<p>Comencemos con el comando <i>docker container run</i> que se usa para ejecutar imágenes dentro de un contenedor. La estructura del comando es la siguiente: <em>container run <i>IMAGE-NAME</i></em> le indicaremos a Docker que cree un contenedor a partir de una imagen. Una característica particularmente interesante del comando es que puede ejecutar un contenedor incluso si la imagen para ejecutar aún no se ha descargado en nuestro dispositivo.</p>\n<p>Ejecutemos el comando</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">§ <span class=\"token function\">docker</span> container run hello-world</code></pre></div>\n<p>Habrá muchos resultados, pero separemoslos en varias secciones, que podemos descifrar juntos. Las líneas están numeradas para que sea más fácil seguir la explicación. Tu output no tendrá los números.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. Unable to <span class=\"token function\">find</span> image <span class=\"token string\">'hello-world:latest'</span> locally\n<span class=\"token number\">2</span>. latest: Pulling from library/hello-world\n<span class=\"token number\">3</span>. b8dfde127a29: Pull complete\n<span class=\"token number\">4</span>. Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c\n<span class=\"token number\">5</span>. Status: Downloaded newer image <span class=\"token keyword\">for</span> hello-world:latest</code></pre></div>\n<p>Debido a que la imagen <i>hello-world</i> no se encontró en nuestra máquina, el comando primero la descargó de un registro gratuito llamado <a href=\"https://hub.docker.com/\">Docker Hub</a>. Puedes ver la página de Docker Hub de la imagen con tu navegador aquí: <a href=\"https://hub.docker.com/_/hello-world\">https://hub.docker.com/_/hello-world</a></p>\n<p>La primera parte del mensaje indica que aún no teníamos la imagen \"hello-world:latest\". Esto revela un poco de detalle sobre las imágenes mismas; los nombres de las imágenes constan de varias partes, como una URL. El nombre de una imagen tiene el siguiente formato:</p>\n<ul>\n<li><em>registry/organisation/image:tag</em></li>\n</ul>\n<p>En este caso, los 3 campos que faltan resuelven por defecto a:</p>\n<ul>\n<li><em>index.docker.io/library/hello-world:latest</em></li>\n</ul>\n<p>La segunda fila muestra el nombre de la organización, \"librería\" donde obtendrá la imagen. En la URL de Docker Hub, la \"librería\" se acorta a _.</p>\n<p>Las filas 3 y 5 solo muestran el estado. Pero la cuarta fila puede ser interesante: cada imagen tiene un resumen único basado en las <i>capas</i> a partir de las cuales se construye la imagen. En la práctica, cada paso o comando que se usó para construir la imagen crea una capa única. Docker usa el resumen para identificar que una imagen es la misma. Esto se hace cuando intenta extraer la misma imagen nuevamente.</p>\n<p>Entonces, el resultado de usar el comando fue extraer y luego generar información sobre la <strong>imagen</strong>. Después de eso, el estado nos dijo que se descargó una nueva versión de hello-world:latest. Puedes intentar extraer la imagen con <em>docker image pull hello-world</em> y ver qué sucede.</p>\n<p>El siguiente output fue del propio contenedor. También explica lo que sucedió cuando ejecutamos <em>docker container run hello-world</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Hello from Docker<span class=\"token operator\">!</span>\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n <span class=\"token number\">1</span>. The Docker client contacted the Docker daemon.\n <span class=\"token number\">2</span>. The Docker daemon pulled the <span class=\"token string\">\"hello-world\"</span> image from the Docker Hub.\n    <span class=\"token punctuation\">(</span>amd64<span class=\"token punctuation\">)</span>\n <span class=\"token number\">3</span>. The Docker daemon created a new container from that image <span class=\"token function\">which</span> runs the\n    executable that produces the output you are currently reading.\n <span class=\"token number\">4</span>. The Docker daemon streamed that output to the Docker client, <span class=\"token function\">which</span> sent it\n    to your terminal.\n\nTo try something <span class=\"token function\">more</span> ambitious, you can run an Ubuntu container with:\n $ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-it</span> ubuntu <span class=\"token function\">bash</span>\n\nShare images, automate workflows, and <span class=\"token function\">more</span> with a <span class=\"token function\">free</span> Docker ID:\n https://hub.docker.com/\n\nFor <span class=\"token function\">more</span> examples and ideas, visit:\n https://docs.docker.com/get-started/</code></pre></div>\n<p>El output contiene algunas cosas nuevas para que aprendamos. <i>Docker daemon</i> es un servicio en segundo plano que se asegura de que los contenedores se estén ejecutando, y usamos el <i>Docker client</i> para interactuar con el daemon. Ahora hemos interactuado con la primera imagen y hemos creado un contenedor a partir de la imagen. Durante la ejecución de ese contenedor, recibimos el output.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.2</h3>\n<p>Algunos de estos ejercicios no requieren que escribas ningún código o configuración en un archivo.\nEn estos ejercicios, debes usar el comando <a href=\"https://man7.org/linux/man-pages/man1/script.1.html\">script</a> para registrar los comandos que has usado; pruébalo con <em>script</em> para comenzar a grabar, <em>echo \"hello\"</em> para generar algún output y <em>exit</em> para detener la grabación. Guarda tus acciones en un archivo llamado \"typescript\" (que no tiene nada que ver con lenguaje de programación TypeScript, el nombre es solo una coincidencia).</p>\n<p>Si <em>script</em> no funciona, puedes simplemente copiar y pegar todos los comandos que utilizaste en un archivo de texto.</p>\n<h4>Ejercicio 12.2: Ejecutando tu segundo contenedor</h4>\n<blockquote>\n<p>Usa <em>script</em> para registrar lo que haces, guarda el archivo en script-answers/exercise12_2.txt</p>\n</blockquote>\n<p>El resultado de hello-world nos dio una tarea ambiciosa que hacer. Haz lo siguiente:</p>\n<blockquote>\n<p>Paso 1. Ejecuta un contenedor de Ubuntu con el comando proporcionado por hello-world</p>\n</blockquote>\n<p>El paso 1 conectará directamente al contenedor con bash. Tendrás acceso a todos los archivos y herramientas dentro del contenedor. Los siguientes pasos se ejecutan dentro del contenedor:</p>\n<ul>\n<li>Paso 2. Crea el directorio <i>/usr/src/app</i></li>\n<li>Paso 3. Crea el archivo <i>/usr/src/app/index.js</i></li>\n<li>Paso 4. Ejecuta <i>exit</i> para salir del contenedor</li>\n</ul>\n<p>Google debería poder ayudarte a crear directorios y archivos.</p>\n</div>\n<div class=\"content\">\n<h3>Imagen de Ubuntu</h3>\n<p>El comando que acabas de usar para ejecutar el contenedor de Ubuntu, <em>docker container run -it ubuntu bash</em>, contiene algunas adiciones al hello-world ejecutado anteriormente. Veamos --help para entenderlo mejor. Cortaré parte del output para que podamos centrarnos en las partes relevantes.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">--help</span>\n\nUsage:  <span class=\"token function\">docker</span> container run <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> IMAGE <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ARG<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\nRun a <span class=\"token builtin class-name\">command</span> <span class=\"token keyword\">in</span> a new container\n\nOptions:\n  <span class=\"token punctuation\">..</span>.\n  -i, <span class=\"token parameter variable\">--interactive</span>                    Keep STDIN <span class=\"token function\">open</span> even <span class=\"token keyword\">if</span> not attached\n  -t, <span class=\"token parameter variable\">--tty</span>                            Allocate a pseudo-TTY\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Las dos opciones, o banderas, <em>-it</em> aseguran que podamos interactuar con el contenedor. Después de las opciones, definimos que la imagen a ejecutar es <em>ubuntu</em>. Luego tenemos el comando <em>bash</em> que se ejecutará dentro del contenedor cuando lo iniciemos.</p>\n<p>Puedes probar otros comandos que la imagen de Ubuntu podría ejecutar. Como ejemplo, prueba <em>docker container run --rm ubuntu ls</em>. El comando <em>ls</em> enumerará todos los archivos en el directorio y la bandera <em>--rm</em> eliminará el contenedor después de la ejecución. Normalmente, los contenedores no se eliminan automáticamente.</p>\n<p>Continuemos con nuestro primer contenedor de Ubuntu con el archivo <strong>index.js</strong> dentro. El contenedor ha dejado de ejecutarse desde que salimos de él. Podemos enumerar todos los contenedores con <em>container ls -a</em>,la <em>-a</em> (o --all) enumerará los contenedores que ya se han cerrado.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">3</span> minutes ago    Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">6</span> seconds ago          hopeful_clarke</code></pre></div>\n<blockquote>\n<p><i>Nota del editor: el comando <em>docker container ls</em> también tiene una forma más corta <em>docker ps</em></i>, yo prefiero la que es más corta.</p>\n</blockquote>\n<p>Tenemos dos opciones a la hora de abordar un contenedor. El identificador de la primera columna se puede utilizar para interactuar con el contenedor casi siempre. Además, la mayoría de los comandos aceptan el nombre del contenedor como un método más amigable para trabajar con ellos. El nombre del contenedor se generó automáticamente para ser <strong>\"hopeful_clarke\"</strong> en mi caso.</p>\n<p>El contenedor ya termino de ejecutarse, pero podemos iniciarlo de nuevo con el comando de inicio que aceptará el id o el nombre del contenedor como parámetro: <em>start <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> start hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>El comando iniciará el mismo contenedor que teníamos anteriormente. Desafortunadamente, olvidamos iniciarlo con la bandera <em>--interactive</em> (que también puede escribirse como <em>-i</em>) por lo que no podemos interactuar con él.</p>\n<p>El contenedor está realmente en funcionamiento como muestra el comando <em>container ls -a</em>, pero simplemente no podemos comunicarnos con el:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">7</span> minutes ago    Up <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">15</span> seconds ago            hopeful_clarke</code></pre></div>\n<p>Ten en cuenta que también podemos ejecutar el comando sin la bandera <em>-a</em> para ver solo los contenedores que se están ejecutando:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS             NAMES\n8f5abc55242a   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">8</span> minutes ago    Up <span class=\"token number\">1</span> minutes       hopeful_clarke             </code></pre></div>\n<p>Matémoslo con el comando <em>kill <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em> e intentemos nuevamente.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token function\">kill</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p><em>docker kill</em> envía una <a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">señal SIGKILL</a> al proceso forzándolo a salir, y eso hace que el contenedor se detenga. Podemos verificar su estado con <em>container ls -a</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED             STATUS                     NAMES\nb8548b9faec3   ubuntu     <span class=\"token string\">\"bash\"</span>   <span class=\"token number\">26</span> minutes ago      Exited <span class=\"token number\">2</span> seconds ago       hopeful_clarke</code></pre></div>\n<p>Ahora iniciemos el contenedor de nuevo, pero esta vez en modo interactivo:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> start <span class=\"token parameter variable\">-i</span> hopeful_clarke\nroot@b8548b9faec3:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Editemos el archivo <i>index.js</i> y agreguemos código JavaScript para ejecutar. Solo nos faltan las herramientas para editar el archivo. Nano será un buen editor de texto por ahora. Las instrucciones de instalación se encontraron en el primer resultado de Google. Omitiremos usar sudo ya que ya somos root.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@b8548b9faec3:/<span class=\"token comment\"># apt-get update</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># apt-get -y install nano</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># nano /usr/src/app/index.js</span></code></pre></div>\n<p>¡Ahora tenemos nano instalado y podemos comenzar a editar archivos!</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.3 - 12.4</h3>\n<h4>Ejercicio 12.3: Ubuntu 101</h4>\n<blockquote>\n<p>Utiliza <em>script</em> para registrar lo que haces, guarda el archivo en script-answers/exercise12_3.txt</p>\n</blockquote>\n<p>Edita el archivo <em>/usr/src/app/index.js</em> dentro del contenedor con Nano y agrega la siguiente línea</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Si no estás familiarizado con Nano, puedes pedir ayuda en el chat o en Google.</p>\n<h4>Ejercicio 12.4: Ubuntu 102</h4>\n<blockquote>\n<p>Utiliza <em>script</em> para registrar lo que haces, guarda el archivo en script-answers/exercise12_4.txt</p>\n</blockquote>\n<p>Instala Node mientras estás dentro del contenedor y ejecuta el archivo index con <em>node /usr/src/app/index.js</em> en el contenedor.</p>\n<p>Las instrucciones para instalar Node a veces son difíciles de encontrar, así que aquí hay algo que puedes copiar y pegar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-sL</span> https://deb.nodesource.com/setup_20.x <span class=\"token operator\">|</span> <span class=\"token function\">bash</span>\n<span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> nodejs</code></pre></div>\n<p>Deberás instalar <em>curl</em> en el contenedor. Se instala de la misma manera que lo hiciste con <em>nano</em>.</p>\n<p>Después de la instalación, asegúrate de que puedes ejecutar tu código dentro del contenedor con el comando:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@b8548b9faec3:/# node /usr/src/app/index.js\nHello World</code></pre></div>\n</div>\n<div class=\"content\">\n<h3>Otros comandos de Docker</h3>\n<p>¡Ahora que tenemos Node instalado, podemos ejecutar JavaScript en el contenedor! Vamos a crear una nueva imagen desde el contenedor. El comando</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">commit CONTAINER-ID-OR-CONTAINER-NAME NEW-IMAGE-NAME</code></pre></div>\n<p>creará una nueva imagen que incluye los cambios que hemos realizado. Puedes usar <em>container diff</em> para verificar los cambios entre la imagen original y el contenedor antes de hacerlo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> commit hopeful_clarke hello-node-world</code></pre></div>\n<p>Puedes enumerar tus imágenes con <em>image ls</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> image <span class=\"token function\">ls</span>\nREPOSITORY                                      TAG         IMAGE ID       CREATED         SIZE\nhello-node-world                                latest      eef776183732   <span class=\"token number\">9</span> minutes ago   252MB\nubuntu                                          latest      1318b700e415   <span class=\"token number\">2</span> weeks ago     <span class=\"token number\">72</span>.8MB\nhello-world                                     latest      d1165f221234   <span class=\"token number\">5</span> months ago    <span class=\"token number\">13</span>.3kB</code></pre></div>\n<p>Ahora puedes ejecutar la nueva imagen de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-node-world <span class=\"token function\">bash</span>\nroot@4d1b322e1aff:/<span class=\"token comment\"># node /usr/src/app/index.js</span></code></pre></div>\n<p>Hay varias formas de hacer lo mismo. Probemos una mejor solución. Limpiaremos la pizarra con <em>container rm</em> para retirar el contenedor antiguo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                  NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">31</span> minutes ago   Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">9</span> seconds ago               hopeful_clarke\n\n$ <span class=\"token function\">docker</span> container <span class=\"token function\">rm</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>Crea un archivo <i>index.js</i> en tu directorio actual y escribe <em>console.log('Hello, World')</em> dentro de él. No hay necesidad de contenedores todavía.</p>\n<p>A continuación, nos saltaremos la instalación manual de Node por completo. Hay muchas imágenes útiles de Docker en Docker Hub, listas para nuestro uso. Usemos la imagen <a href=\"https://hub.docker.com/_/Node\">https://hub.docker.com/_/Node</a>, que ya tiene Node instalado. Sólo tenemos que elegir una versión.</p>\n<p>Por cierto, el <em>container run</em> acepta el indicador <em>--name</em> que podemos usar para dar un nombre al contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--name</span> hello-node node:20 <span class=\"token function\">bash</span></code></pre></div>\n<p>Vamos a crear un directorio para el código dentro del contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@77d1023af893:/# mkdir /usr/src/app</code></pre></div>\n<p>Mientras estamos dentro del contenedor en este terminal, abre otro terminal y usa el comando <em>container cp</em> para copiar el archivo desde tu propia máquina al contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">cp</span> ./index.js hello-node:/usr/src/app/index.js</code></pre></div>\n<p>Y ahora podemos ejecutar <em>node /usr/src/app/index.js</em> en el contenedor. Podemos guardar esto como otra imagen nueva, pero hay una solución aún mejor. La siguiente sección tratará sobre la construcción de tus imágenes como un profesional.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"a","lang":"es"}}},"pageContext":{"part":12,"letter":"a","lang":"es"}},"staticQueryHashes":["3128451518"]}
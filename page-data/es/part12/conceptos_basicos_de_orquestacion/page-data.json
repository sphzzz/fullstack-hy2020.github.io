{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/conceptos_basicos_de_orquestacion","result":{"data":{"markdownRemark":{"html":"<div class=\"tasks\">\n<p>Esta parte fue actualizada el 21 de Marzo de 2024: Create react app reemplazado con Vite en el frontend de todo.</p>\n<p>Si comenzaste esta parte antes de la actualización, puedes ver el viejo material <a href=\"https://github.com/fullstack-hy2020/fullstack-hy2020.github.io/tree/4015af9dddb61cb01f013456d8728e8f553be347/src/content/12\">aquí</a>. Hay algunos cambios en las configuraciones del frontend.</p>\n</div>\n<div class=\"content\">\n<p>Ahora tenemos una comprensión básica de Docker y podemos utilizarlo para fácilmente configurar, por ejemplo, una base de datos para nuestra aplicación. Ahora, cambiemos nuestro enfoque hacia el frontend.</p>\n<h3>React en un contenedor</h3>\n<p>A continuación, vamos a crear y a poner en un contenedor a una aplicación React. Comenzamos con los pasos habituales:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> create vite@latest hello-front -- <span class=\"token parameter variable\">--template</span> react\n$ <span class=\"token builtin class-name\">cd</span> hello-front\n$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span></code></pre></div>\n<p>El siguiente paso es convertir el código JavaScript y CSS en archivos estáticos listos para producción, Vite ya tiene un <em>build</em> como un script npm, así que usemos eso:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> run build\n  <span class=\"token punctuation\">..</span>.\n\n  Creating an optimized production build<span class=\"token punctuation\">..</span>.\n  <span class=\"token punctuation\">..</span>.\n  The build folder is ready to be deployed.\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>¡Excelente! El paso final es encontrar una forma de usar un servidor para servir los archivos estáticos. Como sabrás, podríamos usar nuestro <a href=\"https://expressjs.com/en/starter/static-files.html\">express.static</a> con el servidor Express para servir los archivos estáticos. Te lo dejo como ejercicio para que lo hagas en casa. En su lugar, seguiremos adelante y comenzaremos a escribir nuestro Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span></code></pre></div>\n<p>Eso parece correcto. Hagamos el build y veamos si estamos en el camino correcto. Nuestro objetivo es que la compilación tenga éxito sin errores. Luego usaremos bash para verificar dentro del contenedor para ver si los archivos están allí.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> build <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-t</span> hello-front\n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span>/5<span class=\"token punctuation\">]</span> RUN <span class=\"token function\">npm</span> ci                  \n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span>/5<span class=\"token punctuation\">]</span> RUN <span class=\"token function\">npm</span> run \n <span class=\"token punctuation\">..</span>.             \n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> naming to docker.io/library/hello-front\n\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-front <span class=\"token function\">bash</span>\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls</span>\n  Dockerfile  README.md  dist  index.html  node_modules  package-lock.json  package.json\tpublic\tsrc  vite.config.js\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls dist</span>\n  assets\tindex.html  vite.svg</code></pre></div>\n<p>Una opción válida para servir archivos estáticos ahora que ya tenemos Node en el contenedor es <a href=\"https://www.npmjs.com/package/serve\">serve</a>. Intentemos instalar serve y servir los archivos estáticos mientras estamos dentro del contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@98fa9483ee85:/usr/src/app<span class=\"token comment\"># npm install -g serve</span>\n\n  added <span class=\"token number\">89</span> packages <span class=\"token keyword\">in</span> 2s\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># serve dist</span>\n\n   ┌────────────────────────────────────────┐\n   │                                        │\n   │   Serving<span class=\"token operator\">!</span>                             │\n   │                                        │\n   │   - Local:    http://localhost:3000    │\n   │   - Network:  http://172.17.0.2:3000   │\n   │                                        │\n   └────────────────────────────────────────┘</code></pre></div>\n<p>¡Excelente! Hagamos ctrl+c para salir y luego los agregaremos a nuestro Dockerfile.</p>\n<p>La instalación de serve se convierte en un RUN en el Dockerfile. De esta manera, la dependencia se instala durante el proceso de compilación. El comando para servir el directorio <i>dist</i> se convertirá en el comando para iniciar el contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install -g serve</span></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"serve\"</span>, <span class=\"token string\">\"dist\"</span>]</span></span></code></pre></div>\n<p>Nuestro CMD ahora incluye corchetes y, como resultado, usamos la <i> forma exec</i> de CMD. En realidad, hay <strong>tres</strong> formas diferentes para CMD, de las cuales se prefiere la forma exec. Lee la <a href=\"https://docs.docker.com/reference/dockerfile/#cmd\">documentación</a> para obtener más información.</p>\n<p>Cuando ahora construimos la imagen con <em>docker build . -t hello-front</em> y la ejecutamos con <em>docker run -p 5000:3000 hello-front</em>, la aplicación estará disponible en <a href=\"http://localhost:5000\">http://localhost:5000</a>.</p>\n<h3>Usando múltiples etapas</h3>\n<p>Si bien serve es una opción <i>válida</i>, podemos hacerlo mejor. Un buen objetivo es crear imágenes de Docker para que no contengan nada irrelevante. Con un número mínimo de dependencias, es menos probable que las imágenes se rompan o se vuelvan vulnerables con el tiempo.</p>\n<p>Los <a href=\"https://docs.docker.com/build/building/multi-stage/\">builds de varias etapas</a> están diseñadas para dividir el proceso de compilación en muchas etapas separadas, donde es posible limitar qué partes de los archivos de imagen se mueven entre las etapas. Eso abre posibilidades para limitar el tamaño de la imagen, ya que no todos los subproductos del build son necesarios para la imagen resultante. Las imágenes más pequeñas son más rápidas de cargar y descargar y ayudan a reducir la cantidad de vulnerabilidades que puede tener tu software.</p>\n<p>Con builds de varias etapas, se puede usar una solución probada y robusta como <a href=\"https://es.wikipedia.org/wiki/Nginx\">Nginx</a> para servir archivos estáticos sin muchos dolores de cabeza. La <a href=\"https://hub.docker.com/_/nginx\">página de Nginx</a> de Docker Hub nos brinda la información necesaria para abrir los puertos y \"Alojamiento de contenido estático simple\".</p>\n<p>Usemos el Dockerfile anterior pero cambiemos FROM para incluir el nombre de la etapa:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># El primer FROM ahora es una etapa llamada build-stage</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20 <span class=\"token keyword\">AS</span> build-stage </span></span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"token comment\"># Esta es una nueva etapa, todo lo anterior a esta linea ha desaparecido, excepto por los archivos que queremos COPIAR</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> nginx:1.25-alpine</span></span>\n<span class=\"token comment\"># COPIA el directorio dist de build-stage a /usr/share/nginx/html</span>\n<span class=\"token comment\"># El destino fue encontrado en la pagina de Docker hub</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build-stage</span></span> /usr/src/app/dist /usr/share/nginx/html</span></span></code></pre></div>\n<p>Hemos declarado también <i>otra etapa</i>, de donde solo se mueven los archivos relevantes de la primera etapa (el directorio <i>dist</i>, que contiene el contenido estático).</p>\n<p>Después de que la construimos de nuevo, la imagen está lista para servir el contenido estático. El puerto predeterminado será 80 para Nginx, por lo que algo como <em>-p 8000:80</em> funcionará, por lo que los parámetros del comando RUN deben cambiarse un poco.</p>\n<p>Los builds de varias etapas también incluyen algunas optimizaciones internas que pueden afectar tus builds. Como ejemplo, los builds de varias etapas se saltan las etapas que no se utilizan. Si deseamos usar una etapa para reemplazar una parte de un pipeline de build, como pruebas o notificaciones, debemos pasar <strong>algunos</strong> datos a las siguientes etapas. En algunos casos esto está justificado: copia el código de la etapa de prueba a la etapa de build. Esto garantiza que estás haciendo el build con el código probado.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.13 - 12.14.</h3>\n<h4>Ejercicio 12.13: Frontend de la aplicación de tareas</h4>\n<p>Finalmente, llegamos al frontend de la aplicación de tareas pendientes. Ve a todo-app/todo-frontend y lee el README.</p>\n<p>Comienza ejecutando el frontend fuera del contenedor y asegúrate de que funciona con el backend.</p>\n<p>Pon a la aplicación en un contenedor creando <i>todo-app/todo-frontend/Dockerfile</i> y utiliza a la instrucción <a href=\"https://docs.docker.com/engine/reference/builder/#env\">ENV</a> para pasar <em>VITE_BACKEND_URL</em> a la aplicación y ejecútala con el backend. El backend aún debería estar ejecutándose fuera de un contenedor.</p>\n<p><strong>Ten en cuenta</strong> que debes configurar <em>VITE_BACKEND_URL</em> antes de hacer el build del frontend, de lo contrario, no quedará definida en el código.</p>\n<h4>Ejercicio 12.14: Pruebas durante el proceso de build</h4>\n<p>Una posibilidad interesante que utilizar builds de varias etapas nos da, es usar una etapa de build separada para <a href=\"https://docs.docker.com/language/nodejs/run-tests/\">pruebas</a>. Si la etapa de prueba falla, todo el proceso de build también fallará. Ten en cuenta que puede que no sea la mejor idea mover <i>todas las pruebas</i> para que se realicen durante el build de una imagen, pero puede ser buena idea que existan <i>algunas</i> pruebas relacionadas con la creación de contenedores.</p>\n<p>Extrae un componente llamado <i>Todo</i> que represente a una sola tarea. Escribe una prueba para el nuevo componente y agrega la ejecución de pruebas al proceso de build.</p>\n<p>Puedes agregar una nueva etapa de build para la prueba si lo deseas. Si lo haces, ¡recuerda leer de nuevo el último párrafo antes del ejercicio 12.13!</p>\n</div>\n<div class=\"content\">\n<h3>Desarrollo en contenedores</h3>\n<p>Movamos todo el desarrollo de la aplicación de tareas pendientes a un contenedor. Hay algunas razones por las que querrías hacer eso:</p>\n<ul>\n<li>Para mantener el entorno similar entre el desarrollo y la producción y así evitar errores que aparecen solo en el entorno de producción.</li>\n<li>Evitar diferencias entre los desarrolladores y sus entornos personales que generen dificultades en el desarrollo de aplicaciones.</li>\n<li>Para ayudar a los nuevos miembros del equipo a incorporarse, haciéndoles instalar el tiempo de ejecución del contenedor, sin necesidad de nada más.</li>\n</ul>\n<p>Todas estas son buenas razones. La contrapartida es que podemos encontrarnos con algún comportamiento no convencional cuando no estamos ejecutando las aplicaciones como estamos acostumbrados. Tendremos que hacer al menos dos cosas para mover la aplicación a un contenedor:</p>\n<ul>\n<li>Iniciar la aplicación en modo de desarrollo</li>\n<li>Acceder a los archivos con VSCode</li>\n</ul>\n<p>Comencemos con el frontend. Dado que el Dockerfile será significativamente diferente al Dockerfile de producción, creemos uno nuevo llamado <i>dev.Dockerfile</i>.</p>\n<p><strong>Nota</strong> usaremos el nombre <i>dev.Dockerfile</i> para las configuraciones de desarrollo y <i>Dockerfile</i> para lo demás.</p>\n<p>Iniciar Vite en modo de desarrollo debería ser fácil. Comencemos con lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token comment\"># Cambia npm ci a npm install ya que vamos a estar en modo de desarrollo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install</span>\n\n<span class=\"token comment\"># npm run dev es el comando para iniciar la aplicación en modo de desarrollo</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"npm\"</span>, <span class=\"token string\">\"run\"</span>, <span class=\"token string\">\"dev\"</span>, <span class=\"token string\">\"--\"</span>, <span class=\"token string\">\"--host\"</span>]</span></code></pre></div>\n<blockquote>\n<p>Nota los parámetros adicionales <em>-- --host</em> en el <em>CMD</em>. Esos son necesarios para exponer el servidor de desarrollo y hacerlo visible fuera de la red Docker. Por defecto, el servidor de desarrollo solo se expone a localhost, y a pesar de que accedemos al frontend todavía usando la dirección de localhost, en realidad está conectado a la red Docker.</p>\n</blockquote>\n<p>Durante el build, se usará el indicador <em>-f</em> para indicar qué archivo usar; de lo contrario, el predeterminado sería Dockerfile, por lo que el siguiente comando hará el build de la imagen:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-f</span> ./dev.Dockerfile <span class=\"token parameter variable\">-t</span> hello-front-dev <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>Vite se servirá en el puerto 5173, por lo que puedes probar que funciona al ejecutar un contenedor con ese puerto publicado.</p>\n<p>La segunda tarea, acceder a los archivos con VSCode, aún no se ha realizado. Hay al menos dos formas de hacer esto:</p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/docs/remote/containers\">Extensión de Visual Studio Code Remote - Containers</a></li>\n<li>Volúmenes, lo mismo que usamos para conservar los datos con la base de datos.</li>\n</ul>\n<p>Repasemos esto último, ya que también funcionará con otros editores. Hagamos una ejecución de prueba con el indicador <em>-v</em> y, si funciona, moveremos la configuración a un archivo docker-compose. Para usar <em>-v</em>, necesitaremos decirle el directorio actual. El comando <em>pwd</em> debería generar la ruta al directorio actual. Intentemos esto con <em>echo $(pwd)</em> en la línea de comandos. Podemos usarlo con <em>-v</em> a la izquierda para asignar el directorio actual al interior del contenedor o podemos usar la ruta completa del directorio.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">5173</span>:5173 <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/usr/src/app/\"</span> hello-front-dev\n<span class=\"token operator\">></span> todo-vite@0.0.0 dev\n<span class=\"token operator\">></span> vite <span class=\"token parameter variable\">--host</span>\n\n  VITE v5.1.6  ready <span class=\"token keyword\">in</span> <span class=\"token number\">130</span> ms</code></pre></div>\n<p>Ahora podemos editar el archivo <i>src/App.jsx</i>, ¡y los cambios deberían cargarse de forma instantánea en el navegador!</p>\n<p>Si tienes una Mac con procesador M1/M2, el comando anterior falla. En el mensaje de error, notamos lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error: Cannot find module @rollup/rollup-linux-arm64-gnu</code></pre></div>\n<p>El problema es la librería <a href=\"https://www.npmjs.com/package/rollup\">rollup</a> que tiene su propia versión para todos los sistemas operativos y arquitecturas de procesador. Debido al mapeo de volúmenes, el contenedor ahora está usando los <em>node_modules</em> del directorio de la máquina anfitriona donde está instalado <em>@rollup/rollup-darwin-arm64</em> (la versión adecuada para Mac M1/M2), por lo que no se encuentra la versión correcta de la librería para el contenedor <em>@rollup/rollup-linux-arm64-gnu</em>.</p>\n<p>Hay varias formas de solucionar el problema. Usemos quizás la más simple. Inicia el contenedor con bash como el comando, y ejecuta <em>npm install</em> dentro del contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/usr/src/app/\"</span> front-dev <span class=\"token function\">bash</span>\nroot@b83e9040b91d:/usr/src/app<span class=\"token comment\"># npm install</span></code></pre></div>\n<p>¡Ahora ambas versiones de la librería rollup están instaladas y el contenedor funciona!</p>\n<p>A continuación, movamos la configuración al archivo <i>docker-compose.dev.yml</i>. Este archivo también debe estar en la raíz del proyecto:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> . <span class=\"token comment\"># El contexto tomará este directorio como el \"contexto del build\"</span>\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile <span class=\"token comment\"># Esto simplemente le indicará qué dockerfile leer</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app <span class=\"token comment\"># La ruta puede ser relativa, por lo que ./ es suficiente para decir \"la misma ubicación que el docker-compose.yml\"</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev <span class=\"token comment\"># Esto nombrará el contenedor como hello-front-dev</span></code></pre></div>\n<p>Con esta configuración, <em>docker compose -f docker-compose.dev.yml up</em> puede ejecutar la aplicación en modo de desarrollo. ¡Ni siquiera necesitas tener Node instalado para trabajar en ella!</p>\n<p><strong>Nota</strong> usaremos el nombre <i>docker-compose.dev.yml</i> para los archivos de composición del entorno de desarrollo, y el nombre predeterminado <i>docker-compose.yml</i> en otros casos.</p>\n<p>Instalar nuevas dependencias es un dolor de cabeza para una configuración de desarrollo como esta. Una de las mejores opciones es instalar la nueva dependencia <strong>dentro</strong> del contenedor. Entonces, en lugar de hacer, p.ej. <em>npm install axios</em>, debes hacerlo en el contenedor en ejecución, p.ej. <em>docker exec hello-front-dev npm install axios</em>, o agrégalo a package.json y ejecuta <em>docker build</em> nuevamente.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.15</h3>\n<h4>Ejercicio 12.15: Configurar un entorno de desarrollo frontend</h4>\n<p>Crea <i>todo-frontend/docker-compose.dev.yml</i> y usa volúmenes para habilitar el desarrollo de todo-frontend mientras se ejecuta <i>dentro</i> de un contenedor.</p>\n</div>\n<div class=\"content\">\n<h3>Comunicación entre contenedores en una red Docker</h3>\n<p>La herramienta Docker Compose configura una red entre los contenedores e incluye un DNS para conectar fácilmente dos contenedores. Agreguemos un nuevo servicio a Docker Compose y veremos cómo funcionan la red y el DNS.</p>\n<p><a href=\"https://www.busybox.net/\">Busybox</a> es un pequeño ejecutable con varias herramientas que podrías necesitar. Se llama \"La navaja suiza de Embedded Linux\", y definitivamente podemos usarlo para nuestro beneficio.</p>\n<p>Busybox puede ayudarnos a depurar nuestras configuraciones. Entonces, si te pierdes en los últimos ejercicios de esta sección, puedes usar Busybox para averiguar qué funciona y qué no. Usémoslo para explorar lo que se acaba de decir. Que los contenedores están dentro de una red y que puedes conectarte fácilmente entre ellos. Busybox se puede agregar a la mezcla cambiando <i>docker-compose.dev.yml</i> a:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</span></code></pre></div>\n<p>El contenedor Busybox no tendrá ningún proceso ejecutándose dentro por lo que no podemos usar <em>exec</em> allí. Por eso, la salida de <em>docker compose up</em> también se verá así:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up                                                                                    <span class=\"token number\">0</span>.0s\nAttaching to front-dev, debug-helper-1\ndebug-helper-1 exited with code <span class=\"token number\">0</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span> <span class=\"token operator\">></span> todo-vite@0.0.0 dev\nfront-dev       <span class=\"token operator\">|</span> <span class=\"token operator\">></span> vite <span class=\"token parameter variable\">--host</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span>   VITE v5.2.2  ready <span class=\"token keyword\">in</span> <span class=\"token number\">153</span> ms</code></pre></div>\n<p>Esto es de esperar ya que es solo una caja de herramientas. Usémoslo para enviar una solicitud a hello-front-dev y ver cómo funciona el DNS. Mientras se ejecuta hello-front-dev, podemos realizar la solicitud con <a href=\"https://es.wikipedia.org/wiki/GNU_Wget\">wget</a> ya que es una herramienta incluida en Busybox para enviar una solicitud desde el asistente de depuración a hello-front-dev.</p>\n<p>Con Docker Compose podemos usar <em>docker compose run SERVICE COMMAND</em> para ejecutar un servicio con un comando específico. El comando wget requiere la bandera <em>-O</em> con <em>-</em> para enviar la respuesta a stdout:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml run debug-helper <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> - http://app:5173\n\nConnecting to app:5173 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.240.3:5173<span class=\"token punctuation\">)</span>\nwriting to stdout\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>doctype html<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>html <span class=\"token assign-left variable\">lang</span><span class=\"token operator\">=</span><span class=\"token string\">\"en\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>script <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span><span class=\"token string\">\"module\"</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>La URL es la parte interesante aquí. Simplemente dijimos que se conecte al puerto 5173 del servicio <i>app</i>. <i>app</i> es el nombre del servicio especificado en el archivo <i>docker-compose.dev.yml</i>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span></span>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span></span>    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev</code></pre></div>\n<p>El puerto utilizado es el puerto desde el cual la aplicación está disponible en ese contenedor. No es necesario publicar el puerto para que otros servicios de la misma red puedan conectarse a él. Los \"puertos\" en el archivo docker-compose son solo para acceso externo.</p>\n<p>Cambiemos la configuración del puerto en <i>docker-compose.dev.yml</i> para enfatizar esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> 3210<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span></span>    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</code></pre></div>\n<p>Con <em>docker compose up</em> la aplicación está disponible en <a href=\"http://localhost:3210\">http://localhost:3210</a> en la <i>máquina host</i>, pero el comando</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose  <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml run debug-helper <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> - http://app:5173</code></pre></div>\n<p>funciona ya que el puerto sigue siendo 5173 dentro de la red docker.</p>\n<p>La imagen de abajo ilustra lo que sucede. El comando <em>docker compose run</em> le pide a debug-helper que envíe la solicitud dentro de la red. Mientras que el navegador en la máquina host envía la solicitud desde fuera de la red.</p>\n<picture><img src=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png\" srcset=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/772e8/busybox_networking_drawio.png 200w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/e17e5/busybox_networking_drawio.png 400w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png 441w\" sizes=\"(max-width: 441px) 100vw, 441px\"></picture>\n<p>Ahora que sabes lo fácil que es encontrar otros servicios en <i>docker-compose.yml</i> y no tenemos nada que depurar, podemos eliminar debug-helper y revertir los puertos a 5173:5173 en nuestro archivo compose.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.16</h3>\n<h4>Ejercicio 12.16: Ejecutar todo-backend en un contenedor de desarrollo</h4>\n<p>Utiliza volúmenes y Nodemon para permitir el desarrollo del backend de la aplicación de tareas mientras se ejecuta <i>dentro</i> de un contenedor. Crea un archivo <i>todo-backend/dev.Dockerfile</i> y edita a <i>todo-backend/docker-compose.dev.yml</i>.</p>\n<p>También deberás repensar las conexiones entre el backend y MongoDB / Redis. Afortunadamente, Docker Compose puede incluir variables de entorno que se pasarán a la aplicación:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n      <span class=\"token punctuation\">-</span> REDIS_URL=redisurl_here\n      <span class=\"token punctuation\">-</span> MONGO_URL=mongourl_here</code></pre></div>\n<p>Las URL son incorrectas a propósito, deberás poner los valores correctos. Recuerda <i>mirar todo el tiempo lo que sucede en la consola</i>. Si y cuándo las cosas exploten, los mensajes de error insinuaran lo que podría estar roto.</p>\n<p>Aquí hay una imagen posiblemente útil que ilustra las conexiones dentro de la red de docker:</p>\n<picture><img src=\"/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png\" alt=\"diagrama de conexión entre navegador, backend, mongo y redis\" srcset=\"/static/e866965c916d7f8e5a8515d3aa16bc44/772e8/ex_12_15_backend_drawio.png 200w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/e17e5/ex_12_15_backend_drawio.png 400w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png 467w\" sizes=\"(max-width: 467px) 100vw, 467px\"></picture>\n</div>\n<div class=\"content\">\n<h3>Comunicaciones entre contenedores en un entorno más ambicioso</h3>\n<p>A continuación, agregaremos un <a href=\"https://es.wikipedia.org/wiki/Proxy_inverso\">proxy inverso</a> a nuestro docker-compose.dev.yml. Según wikipedia</p>\n<blockquote>\n<p><i>Un proxy inverso es un tipo de servidor proxy que recupera recursos en nombre de un cliente desde uno o más servidores. Estos recursos luego se devuelven al cliente, apareciendo como si se originaran en el propio servidor proxy inverso.</i></p>\n</blockquote>\n<p>Entonces, en nuestro caso, el proxy inverso será el único punto de entrada a nuestra aplicación, y el objetivo final será establecer tanto el frontend de React como el backend de Express detrás del proxy inverso.</p>\n<p>Hay múltiples opciones diferentes para una implementación de proxy inverso, como Traefik, Caddy, Nginx y Apache (ordenadas por versión inicial de más reciente a más antigua).</p>\n<p>Nuestra elección es <a href=\"https://hub.docker.com/_/nginx\">Nginx</a>.</p>\n<p>Ahora pongamos <i>hello-frontend</i> detrás del proxy inverso.</p>\n<p>Crea un archivo <i>nginx.dev.conf</i> en la raíz del proyecto y usa la siguiente plantilla como punto de partida. Tendremos que hacer ediciones menores para que nuestra aplicación se ejecute:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># events es requerido, pero los valores por defecto están bien</span>\nevents <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># Un servidor http, escuchando en el puerto 80</span>\nhttp <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\"># Requests comenzando con root (/) son manejados</span>\n    location / <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\"># Las siguientes 3 lineas son requeridas para que el hot loading funcione (websocket).</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n      <span class=\"token comment\"># Requests son dirigidos a http://localhost:5173</span>\n      proxy_pass http://localhost:5173<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Nota</strong> estamos usando la misma convención para nombres de archivos también para Nginx, <i>nginx.dev.conf</i> para configuraciones de desarrollo, y y el nombre por defecto <i>nginx.conf</i> para producción.</p>\n<p>A continuación, crea un servicio Nginx en el archivo <i>docker-compose.dev.yml</i>. Agrega un volumen como se indica en la página de Docker Hub donde el lado derecho es <em>:/etc/nginx/nginx.conf:ro</em>, el ro final declara que el volumen será <i>solo de lectura (read only)</i>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># ...</span>\n  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.dev.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app <span class=\"token comment\"># esperar a que el contenedor frontend arranque</span></code></pre></div>\n<p>con eso agregado, podemos ejecutar <em>docker compose -f docker-compose.dev.yml up</em> y ver qué sucede.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE            COMMAND  PORTS                   NAMES\na02ae58f3e8d   nginx:1.20.1     <span class=\"token punctuation\">..</span>.      <span class=\"token number\">0.0</span>.0.0:8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp    reverse-proxy\n5ee0284566b4   hello-front-dev  <span class=\"token punctuation\">..</span>.      <span class=\"token number\">0.0</span>.0.0:5173-<span class=\"token operator\">></span><span class=\"token number\">5173</span>/tcp  hello-front-dev</code></pre></div>\n<p>Conectarse a <a href=\"http://localhost:8080\">http://localhost:8080</a> conducirá a una página que se ve familiar con estado 502.</p>\n<p>Esto se debe a que dirigir las solicitudes a <a href=\"http://localhost:5173\">http://localhost:5173</a> no conduce a ninguna parte, ya que el contenedor Nginx no tiene una aplicación ejecutándose en el puerto 5173. Por definición, localhost se refiere a la computadora actual utilizada para acceder a él. Con los contenedores, localhost es único para cada contenedor, lo que lleva al contenedor en sí.</p>\n<p>Probemos esto ingresando al contenedor Nginx y usando curl para enviar una solicitud a la aplicación. En nuestro caso de uso, curl es similar a wget, pero no necesitará ninguna bandera.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> reverse-proxy <span class=\"token function\">bash</span>  \n\nroot@374f9e62bfa8:<span class=\"token punctuation\">\\</span># <span class=\"token function\">curl</span> http://localhost:80\n  <span class=\"token operator\">&lt;</span>html<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>title<span class=\"token operator\">></span><span class=\"token number\">502</span> Bad Gateway<span class=\"token operator\">&lt;</span>/title<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>/head<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Para ayudarnos, Docker Compose configuró una red cuando ejecutamos <em>docker compose up</em>. También agregó todos los contenedores en <i>docker-compose.dev.yml</i> a la red. Un DNS se asegura de que podamos encontrar el otro contenedor. Cada uno de los contenedores recibe dos nombres: el nombre del servicio y el nombre del contenedor.</p>\n<p>Como estamos dentro del contenedor, ¡también podemos probar el DNS! Modifiquemos el nombre del servicio (app) en el puerto 5173</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">root@374f9e62bfa8:\\# curl http://app:5173\n<span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">doctype</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/@vite/client<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>icon<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/svg+xml<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/vite.svg<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>width=device-width, initial-scale=1.0<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Vite + React<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>root<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/src/main.jsx<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>¡Eso es! Reemplacemos la dirección proxy_pass en nginx.conf con esa.</p>\n<p>Una cosa más: agregamos una opción <a href=\"https://docs.docker.com/compose/compose-file/05-services/#depends_on\">depends_on</a> a la configuración que garantiza que el contenedor <em>nginx</em> no se inicie antes que el contenedor frontend <em>app</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">services:\n  app:\n    <span class=\"token comment\"># ...</span>\n  nginx:\n    image: nginx:1.20.1\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    ports:\n      - <span class=\"token number\">8080</span>:80\n    container_name: reverse-proxy\n<span class=\"gatsby-highlight-code-line\">    depends_on:</span><span class=\"gatsby-highlight-code-line\">      - app</span></code></pre></div>\n<p>Si no hacemos cumplir el orden de inicio con <i>depends_on</i>, existe el riesgo de que Nginx falle en el inicio, ya que intenta recuperar todos los nombres de DNS a los que se hace referencia en el archivo de configuración:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">http <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    location / <span class=\"token punctuation\">{</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n<span class=\"gatsby-highlight-code-line\">      proxy_pass http://app:5173<span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ten en cuenta que <i>depends_on</i> no garantiza que el servicio en el contenedor dependiente esté listo para la acción, solo asegura que el contenedor se haya iniciado (y la entrada correspondiente se agregue al DNS). Si un servicio necesita esperar a que otro servicio esté listo antes del inicio, se deben usar <a href=\"https://docs.docker.com/compose/startup-order/\">otras soluciones</a>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.17. - 12.19.</h3>\n<h4>Ejercicio 12.17: Configura un servidor proxy inverso Nginx delante de todo-frontend</h4>\n<p>A continuación vamos a poner el servidor nginx delante de todo-frontend y todo-backend. Comencemos creando un nuevo archivo docker-compose <i>todo-app/docker-compose.dev.yml</i> y <i>todo-app/nginx.dev.conf</i>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n<span class=\"gatsby-highlight-code-line\">├── nginx.dev.conf</span><span class=\"gatsby-highlight-code-line\">└── docker-compose.dev.yml</span></code></pre></div>\n<p>Agrega los servicios Nginx y todo-frontend creados con <i>todo-app/todo-frontend/dev.Dockerfile</i> en <i>todo-app/docker-compose.dev.yml</i>.</p>\n<picture><img src=\"/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png\" alt=\"diagrama de conexión entre navegador, nginx, express y frontend\" srcset=\"/static/a5c3b8d70abca3569ed532e053af7bc7/772e8/ex_12_16_nginx_front.png 200w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/e17e5/ex_12_16_nginx_front.png 400w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<p>En este y en los siguientes ejercicios <strong>no necesitas</strong> darle soporte a la opción build, eso es, el comando:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up <span class=\"token parameter variable\">--build</span></code></pre></div>\n<p>Es suficiente hacer el build del frontend y el backend en sus propios repositorios.</p>\n<h4>Ejercicio 12.18: Configura el servidor Nginx para que esté delante de todo-backend</h4>\n<p>Agrega el servicio todo-backend al archivo docker-compose <i>todo-app/docker-compose.dev.yml</i> en el modo de desarrollo.</p>\n<p>Agrégale una nueva ubicación al archivo <i>nginx.dev.conf</i>, para que las solicitudes a <em>/api</em> se transmitan al backend a través del proxy. Algo como esto debería hacer el truco:</p>\n<div class=\"gatsby-highlight\" data-language=\"conf\"><pre class=\"language-conf\"><code class=\"language-conf\">  server {\n    listen 80;\n\n    # Requests comenzando con root (/) son manejados\n    location / {\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &#39;upgrade&#39;;\n      \n      proxy_pass ...\n    }\n\n    # Requests comenzando con /api/ son manejados\n    location /api/ {\n      proxy_pass ...\n    }\n  }</code></pre></div>\n<p>La directiva <em>proxy_pass</em> tiene una característica interesante con una barra inclinada final. Como estamos usando la ruta <em>/api</em> para la ubicación, pero la aplicación backend solo responde en las rutas <em>/</em> o <em>/todos</em>, queremos que se elimine <em>/api</em> de la solicitud. En otras palabras, aunque el navegador envíe una solicitud GET a <em>/api/todos/1</em>, queremos que Nginx envíe la solicitud a <em>/todos/1</em>. Haz esto agregando una barra inclinada final <em>/</em> a la URL al final de <em>proxy_pass</em>.</p>\n<p>Este es un <a href=\"https://serverfault.com/questions/562756/how-to-remove-the-path-with-an-nginx-proxy-pass\">problema común</a></p>\n<picture><img src=\"/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png\" alt=\"comentarios sobre haber olvidado usar la barra inclinada\" srcset=\"/static/356d6b54ad3287d7e031093366b578bf/772e8/nginx_trailing_slash_stackoverflow.png 200w,\n/static/356d6b54ad3287d7e031093366b578bf/e17e5/nginx_trailing_slash_stackoverflow.png 400w,\n/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png 666w\" sizes=\"(max-width: 666px) 100vw, 666px\"></picture>\n<p>Esto ilustra lo que estamos buscando y puede ser útil si tienes problemas:</p>\n<picture><img src=\"/static/588d3e2d00a8bd46cb059cc22b648839/15d25/nginx-back-vite.png\" alt=\"diagrama de llamado a / y /api en acción\" srcset=\"/static/588d3e2d00a8bd46cb059cc22b648839/772e8/nginx-back-vite.png 200w,\n/static/588d3e2d00a8bd46cb059cc22b648839/e17e5/nginx-back-vite.png 400w,\n/static/588d3e2d00a8bd46cb059cc22b648839/15d25/nginx-back-vite.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<h4>Ejercicio 12.19: Conecta los servicios, todo-frontend con todo-backend</h4>\n<blockquote>\n<p>En este ejercicio, envía todo el entorno de desarrollo, incluyendo ambas aplicaciones Express y React, dev.Dockerfiles y docker-compose.dev.yml.</p>\n</blockquote>\n<p>Finalmente, es hora de juntar todas las piezas. Antes de empezar, es esencial entender <i>dónde</i> se ejecuta realmente la aplicación React. El diagrama anterior podría dar la impresión de que la aplicación React se ejecuta en el contenedor, pero esto es completamente incorrecto.</p>\n<p>Es solo el <em>código fuente de la aplicación React</em> lo que está en el contenedor. Cuando el navegador accede a la dirección <a href=\"http://localhost:8080\">http://localhost:8080</a> (suponiendo que hayas configurado Nginx para ser accesible en el puerto 8080), el código fuente de React se descarga del contenedor al navegador:</p>\n<picture><img src=\"/static/173caa8364344802dfa484a3fe62eb8f/3ebb1/nginx-setup-vite.png\" alt=\"diagrama mostrando que el código de react es enviado al navegador para su ejecución\" srcset=\"/static/173caa8364344802dfa484a3fe62eb8f/772e8/nginx-setup-vite.png 200w,\n/static/173caa8364344802dfa484a3fe62eb8f/e17e5/nginx-setup-vite.png 400w,\n/static/173caa8364344802dfa484a3fe62eb8f/3ebb1/nginx-setup-vite.png 507w\" sizes=\"(max-width: 507px) 100vw, 507px\"></picture>\n<p>A continuación, el navegador comienza a ejecutar la aplicación React, y todas las solicitudes que hace al backend deben hacerse a través del proxy inverso Nginx:</p>\n<picture><img src=\"/static/5c2e45fa07a35a51f5e7ec209d497690/92e00/nginx-setup2.png\" alt=\"diagrama mostrando solicitudes hechas desde al navegador a /api de nginx y el proxy en acción solicitando a /todos\" srcset=\"/static/5c2e45fa07a35a51f5e7ec209d497690/772e8/nginx-setup2.png 200w,\n/static/5c2e45fa07a35a51f5e7ec209d497690/e17e5/nginx-setup2.png 400w,\n/static/5c2e45fa07a35a51f5e7ec209d497690/92e00/nginx-setup2.png 511w\" sizes=\"(max-width: 511px) 100vw, 511px\"></picture>\n<p>En realidad solo accedemos al contenedor frontend en la primera solicitud, la cual obtiene el código fuente de la aplicación React para el navegador.</p>\n<p>Ahora configura tu aplicación para que funcione como se muestra en la figura anterior. Asegúrate de que el todo-frontend funcione con todo-backend. Esto requerirá cambios en la variable de entorno <em>VITE_BACKEND_URL</em> en el frontend.</p>\n<p>Asegúrate de que el entorno de desarrollo ahora esté completamente funcional, es decir:</p>\n<ul>\n<li>todas las funcionalidades de la aplicación de tareas funcionan</li>\n<li>puedes editar los archivos fuente <em>y</em> los cambios se reflejan al recargar la aplicación</li>\n<li>el frontend debe acceder al backend a través de Nginx, por lo que las solicitudes deben hacerse a <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a>:</li>\n</ul>\n<picture><img src=\"/static/dba7f9421034549551a10a7c0063fc84/5a190/todos-dev-right-2.png\" alt=\"pestaña de red de las herramientas de desarrollo del navegador mostrando que la url a la que el navegador llama incluye 8080/api/todos\" srcset=\"/static/dba7f9421034549551a10a7c0063fc84/772e8/todos-dev-right-2.png 200w,\n/static/dba7f9421034549551a10a7c0063fc84/e17e5/todos-dev-right-2.png 400w,\n/static/dba7f9421034549551a10a7c0063fc84/5a190/todos-dev-right-2.png 800w,\n/static/dba7f9421034549551a10a7c0063fc84/c1b63/todos-dev-right-2.png 1200w,\n/static/dba7f9421034549551a10a7c0063fc84/29007/todos-dev-right-2.png 1600w,\n/static/dba7f9421034549551a10a7c0063fc84/010dc/todos-dev-right-2.png 1714w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Ten en cuenta que tu aplicación debe funcionar incluso si no se definen <a href=\"https://docs.docker.com/network/#published-ports\">puertos expuestos</a> para el backend y el frontend en el archivo docker compose:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> todo<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./todo<span class=\"token punctuation\">-</span>frontend/<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token comment\"># no hay puertos aquí!</span>\n\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> todo<span class=\"token punctuation\">-</span>back<span class=\"token punctuation\">-</span>dev\n      <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> ./todo<span class=\"token punctuation\">-</span>backend/<span class=\"token punctuation\">:</span>/usr/src/app\n      <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n        <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n      <span class=\"token comment\"># no hay puertos aquí!</span>\n\n  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span> <span class=\"token comment\"># esto es necesario</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app</code></pre></div>\n<p>Solo necesitamos exponer el puerto de Nginx a la máquina host ya que el acceso al backend y frontend funciona a través del proxy de Nginx, el cual lo envía al puerto correcto del contenedor. Debido a que Nginx, frontend y backend están definidos en la misma configuración de Docker compose, Docker los pone en la misma <a href=\"https://docs.docker.com/network/\">Docker network</a> y gracias a eso, Nginx tiene acceso directo a los puertos de los contenedores frontend y backend.</p>\n</div>\n<div class=\"content\">\n<h3>Herramientas para la producción</h3>\n<p>Los contenedores son herramientas divertidas para usar en el desarrollo, pero el mejor caso de uso para ellos es en el entorno de producción. Hay muchas herramientas más potentes que Docker Compose para ejecutar contenedores en producción.</p>\n<p>Herramientas de orquestación de contenedores pesados como <a href=\"https://kubernetes.io/\">Kubernetes</a> nos permiten administrar contenedores en un nivel completamente nuevo. Estas herramientas ocultan las máquinas físicas y nos permiten a nosotros, los desarrolladores, preocuparnos menos por la infraestructura.</p>\n<p>Si estás interesado en obtener más información sobre los contenedores, accede al curso <a href=\"https://devopswithdocker.com\">DevOps con Docker</a> y podrás encontrar más información sobre Kubernetes en el curso avanzado de 5 créditos <a href=\"https://devopswithkubernetes.com\">DevOps con Kubernetes</a> curso. ¡Ahora deberías tener las habilidades para completar ambos!</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.20.-12.22.</h3>\n<h4>Ejercicio 12.20:</h4>\n<p>Crea un archivo de producción <i>todo-app/docker-compose.yml</i> con todos los servicios, Nginx, todo-backend, todo-frontend, MongoDB y Redis. Utiliza Dockerfiles en lugar de <i>dev.Dockerfiles</i> y asegúrate de iniciar las aplicaciones en modo de producción.</p>\n<p>Utiliza la siguiente estructura para este ejercicio:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n├── nginx.dev.conf\n├── docker-compose.dev.yml\n<span class=\"gatsby-highlight-code-line\">├── nginx.conf</span><span class=\"gatsby-highlight-code-line\">└── docker-compose.yml</span></code></pre></div>\n<h4>Ejercicio 12.21:</h4>\n<p>Crea un entorno de desarrollo en contenedores similar para una de tus <i>propias</i> aplicaciones, puedes usar las que hayas creado durante el curso o en tu tiempo libre. Debes estructurar la aplicación en tu repositorio de envío de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    ├── nginx.dev.conf\n    └── docker-compose.dev.yml</code></pre></div>\n<h4>Ejercicio 12.22:</h4>\n<p>Termina esta parte creando una <i>configuración de producción</i> en contenedores de tu propia aplicación.\nEstructura la aplicación en tu repositorio de envío de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    ├── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── nginx.dev.conf\n    ├── nginx.conf\n    ├── docker-compose.dev.yml\n    └── docker-compose.yml</code></pre></div>\n<h3>Envío de ejercicios y obtención de créditos.</h3>\n<p>Este fue el último ejercicio de esta sección. Es hora de enviar tu código a GitHub y marcar todos sus ejercicios terminados en el <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">sistema de envío de ejercicios</a>.</p>\n<p>Los ejercicios de esta parte se envían al igual que en las partes anteriores, pero a diferencia de las partes 0 a 7, la presentación va a una <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">instancia propia del curso</a>. ¡Recuerda que tienes que terminar <i>todos los ejercicios</i> para aprobar esta parte!</p>\n<p>Una vez que hayas completado los ejercicios y quieras obtener los créditos, infórmanos a través del sistema de envío de ejercicios que has completado el curso:</p>\n<picture><img src=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png\" alt=\"Submissions\" srcset=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/772e8/21.png 200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/e17e5/21.png 400w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png 800w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/c1b63/21.png 1200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/29007/21.png 1600w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/74e37/21.png 1732w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><strong>Ten en cuenta</strong> que necesitas registrarte en la parte del curso correspondiente para obtener los créditos registrados, consulta <a href=\"/es/part0/informacion_general#partes-y-finalizacion\">aquí</a> para obtener más información.</p>\n<p>Puedes descargar el certificado por completar esta parte haciendo clic en uno de los íconos de bandera. El ícono de la bandera corresponde al idioma del certificado.</p>\n</div>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"c","lang":"es"}}},"pageContext":{"part":12,"letter":"c","lang":"es"}},"staticQueryHashes":["3128451518"]}